import { Claim, ClaimStatus } from '@domain/entities';
import { RiskAssessmentService } from '@domain/services/RiskAssessmentService';
import { DomainException } from '@domain/exceptions';
import { ErrorCode } from '@domain/types';
import type { IRiskAssessmentService } from '@domain/ports/IRiskAssessmentService';
import { createClaimSchema } from '@application/validators';
import { CreateClaimDTO } from '@application/dtos/CreateClaimDTO';
import { ClaimResponseDTO } from '@application/dtos/ClaimResponseDTO';
import { IClaimRepository } from '@application/ports/IClaimRepository';

export class CreateClaimUseCase {
  private riskAssessmentService: RiskAssessmentService;

  constructor(
    private claimRepository: IClaimRepository,
    private riskAssessmentServicePort: IRiskAssessmentService,
  ) {
    this.riskAssessmentService = new RiskAssessmentService();
  }

  async execute(claimData: CreateClaimDTO): Promise<ClaimResponseDTO> {
    // 1. Validate input data
    const { error: validationError, value } = createClaimSchema.validate(claimData, {
      abortEarly: false,
    });

    if (validationError) {
      const errorMessage = validationError.details.map((detail: any) => detail.message).join(', ');
      throw new DomainException(errorMessage, ErrorCode.VALIDATION_ERROR, {
        details: validationError.details,
      });
    }

    // 2. Create claim entity
    const claim = new Claim(
      '', // ID will be generated by repository
      'user-mock', // TODO: Get from auth or create user
      value.description,
      value.amount,
      ClaimStatus.PENDING,
      value.incidentDate,
    );

    // 2. Save claim to repository
    const savedClaim = await this.claimRepository.create(claim);

    // 3. Generate risk assessment request (domain logic)
    const riskAssessmentRequest =
      this.riskAssessmentService.generateRiskAssessmentRequest(savedClaim);

    // 4. Call AI service to calculate risk
    const { data: aiJsonResponse, error: aiError } =
      await this.riskAssessmentServicePort.calculateRisk(riskAssessmentRequest);

    // 5. Handle AI service errors
    if (aiError) {
      throw new DomainException(
        `AI risk assessment failed: ${aiError.message}`,
        ErrorCode.EXTERNAL_SERVICE_ERROR,
        { originalError: aiError },
      );
    }

    if (!aiJsonResponse) {
      throw new DomainException(
        'Risk assessment failed: No response from AI service',
        ErrorCode.EXTERNAL_SERVICE_ERROR,
      );
    }

    // 6. Parse and validate AI response (domain logic)
    const riskCalculation = this.riskAssessmentService.parseAIResponse(aiJsonResponse);

    // 7. Create risk assessment entity
    const riskAssessment = this.riskAssessmentService.createAssessment(
      savedClaim.claimId,
      riskCalculation.riskScore,
      riskCalculation.recommendedAction,
      riskCalculation.category,
      riskCalculation.reasoning,
    );

    // 8. Set AI recommendation and update status to MANUAL_REVIEW
    // Note: Status always goes to MANUAL_REVIEW to prevent AI auto-approval/rejection
    savedClaim.setAIRecommendation(riskCalculation.recommendedAction);

    // 9. Save risk assessment to claim in database
    await this.claimRepository.updateWithRiskAssessment(savedClaim.claimId, riskAssessment);

    // 10. Return complete response
    return {
      claimId: savedClaim.claimId,
      userId: savedClaim.userId,
      description: savedClaim.description,
      amount: savedClaim.amount,
      status: savedClaim.status,
      aiRecommendation: savedClaim.aiRecommendation,
      submittedAt: savedClaim.submittedAt,
      riskAssessment: {
        riskScore: riskAssessment.riskScore,
        recommendedAction: riskAssessment.recommendedAction,
        category: riskAssessment.category,
        reasoning: riskAssessment.reasoning,
      },
    };
  }
}
