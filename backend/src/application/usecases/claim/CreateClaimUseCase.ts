import { Claim, ClaimStatus } from '@domain/entities';
import { RiskAssessmentService } from '@domain/services/RiskAssessmentService';
import { DomainException } from '@domain/exceptions';
import { ErrorCode } from '@domain/types';
import type { IRiskAssessmentService } from '@domain/ports/IRiskAssessmentService';
import { createClaimSchema } from '@application/validators';
import { CreateClaimDTO } from '@application/dtos/CreateClaimDTO';
import { ClaimResponseDTO } from '@application/dtos/ClaimResponseDTO';
import { IClaimRepository } from '@application/ports/IClaimRepository';

export class CreateClaimUseCase {
  private riskAssessmentService: RiskAssessmentService;

  constructor(
    private claimRepository: IClaimRepository,
    private riskAssessmentServicePort: IRiskAssessmentService,
  ) {
    this.riskAssessmentService = new RiskAssessmentService();
  }

  async execute(claimData: CreateClaimDTO): Promise<ClaimResponseDTO> {
    // 1. Validate input data
    const { error: validationError, value } = createClaimSchema.validate(claimData, {
      abortEarly: false,
    });

    if (validationError) {
      const errorMessage = validationError.details.map((detail: any) => detail.message).join(', ');
      throw new DomainException(errorMessage, ErrorCode.VALIDATION_ERROR, {
        details: validationError.details,
      });
    }

    // 2. Create claim entity
    const claim = new Claim(
      '', // ID will be generated by repository
      'user-mock', // TODO: Get from auth or create user
      value.description,
      value.amount,
      ClaimStatus.PENDING,
      value.incidentDate,
    );

    // 2. Save claim to repository
    const savedClaim = await this.claimRepository.create(claim);

    // 3. Generate risk assessment request (domain logic)
    const riskAssessmentRequest =
      this.riskAssessmentService.generateRiskAssessmentRequest(savedClaim);

    // 4. Calculate risk score using external service (OpenAI)
    const { data: aiResponse, error: aiError } =
      await this.riskAssessmentServicePort.calculateRisk(riskAssessmentRequest);

    let riskCalculation;

    // 5. If external service fails, use domain business rules
    if (aiError) {
      console.warn(
        `External risk assessment failed: ${aiError.message}. Using domain business rules.`,
      );
      riskCalculation = this.riskAssessmentService.calculateRiskByBusinessRules(savedClaim);
    } else if (aiResponse) {
      riskCalculation = aiResponse;
    } else {
      throw new Error('Risk assessment failed: No data or error returned');
    }

    // 7. Create risk assessment entity
    const riskAssessment = this.riskAssessmentService.createAssessment(
      savedClaim.claimId,
      riskCalculation.riskScore,
      riskCalculation.recommendedAction,
    );

    // 8. TODO: Save risk assessment to repository

    // 9. Update claim status based on recommendation
    savedClaim.updateStatus(ClaimStatus[riskCalculation.recommendedAction]);

    // 10. TODO: Update claim in repository

    // 11. Return complete response
    return {
      claimId: savedClaim.claimId,
      userId: savedClaim.userId,
      description: savedClaim.description,
      amount: savedClaim.amount,
      status: savedClaim.status,
      submittedAt: savedClaim.submittedAt,
      riskAssessment: {
        riskScore: riskAssessment.riskScore,
        recommendedAction: riskAssessment.recommendedAction,
      },
    };
  }
}
